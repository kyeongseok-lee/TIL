# Stack



## 스택의 특성 

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
- 스택에 저장된 자료는 선형구조를 갖는다.
  - 선형구조 : 자료 간의 관계가 1:1의 관계를 갖는다.
  - 비선형구조 : 자료 간의 관계가 1:N의 관계를 갖는다.
- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last-In-First-Out)







## 스택의 구현



#### 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산

- 자료 구조 : 자료를 선형으로 저장할 저장소
  - C언어에서는 배열을 사용할 수 있다.
  - 저장소 자체를 스택이라 부르기도 한다.
  - 스택에 마지막 삽입된 원소의 위치를  top이라 부른다.
- 연산
  - 삽입 : 저장소에 자료를 저장한다. 보통 push라고 부른다
  - 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부른다.
  - 스택이 공백인지 아닌지를 확인하는 연산. isEmpty
  - 스택의 top에 있는 item(원소) 을 반환하는 연산. peek



#### 고려 사항

- 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 여렵다는 단점이 있다.
- 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장접을 가진다. 스택의 동적 구현은 생략한다.





## 스택의 응용

#### 1. 괄호 검사

#### 2. function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
  -  가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서를 관리
  - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
  - 함수의 실행이 끝나면 시스템 스택의  top 원소를 삭제하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
  - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스텍이 된다.







## 재귀 호출

- 자기 자신을 호출하여 순환 수행 되는 것
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

```python
// 재귀 호출 기초
// 어떤 흐름으로 함수 호출이 이루어지는지 반드시 이해
// 매개 변수를 이용하여 언제 재귀 호출을 중단할지 판단
def hello(i, n):
    if i == n:
        global cnt
        cnt += 1
        return 1
    else:
        l = hello(i+1, n)
        r = hello(i+1, n)
        return l + r

cnt = 0
print(hello(0, 4))
print(cnt)
```





## Memoization

- 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록하여 실행속도를 빠르게 하는 기술이다. 동적계획법의 핵심이 되는 기술이다.
- `memoization`은 글자 그대로 해석하면 `메모리에 넣기`라는 의미이다.

```python
// 피보나치 비교

// 1.일반 재귀
def fibo(n):
    if n <= 2: return 1

    return fibo(n-1) + fibo(n-2)
print(fibo(35))


// 2. 메모이제이션 적용
memo = [0, 1, 1] + [0] * 100

def fibo_memo(n):
    if n <= 2: return 1
    if memo[n]: return memo[n]

    memo[n] = fibo_memo(n-1) + fibo_memo(n-2)
    return memo[n]
print(fibo_memo(35))
```







## DP (Dynamic Programming)

- 동적 계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 동적 계획 알고리즘은 먼저 입력 크기(문제의 크기)가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

```python
// DP 적용

def fibo_iter(n):
    f = [0] * (n+1)
    f[1] =  f[2] = 1
    for i in range(2, n+1):
        f[i] = f[i - 1] + f[i-2]
    return f[n]

print(fibo_iter(5))
```







## 그래프

- 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결관계를 표현한다.
- 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
  -  |V| : 정점의 개수, |E| : 그래프에 포함된 간선의 개수
  - |V|개의 정점을 가지는 그래프는 최대 |V|(|V|-1)/2 간선이 가능
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 M:N 관계를 가지는 원소들을 표현하기에 용이하다





#### 그래프 유형

- 무향 그래프 (동등, 대등)
- 유향 그래프
- 가중치 그래프
- 사이클 없는 방향 그래프



#### 그래프 경로

- 경로란 간선들을 순서대로 나열한 것
  - 간선들 : (0, 2), (2, 4), (4, 6) 
  - 정점들: 0-2-4-6

- 경로 중 한 정점을 최대 한번만 지나는 경로를 단순경로라 한다.
- 시작한 정점에서 끝나는 경로를 사이클이라고 한다.
  - 1-3-5-1





#### 그래프 표현

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접행렬
  - |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
  - 배열의 배열( 포인터 배열 )
- 인접 리스트
  - 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
- 간선의 배열
  - 간선을 배열에 연속적으로 저장









## DFS (깊이 우선 탐색)

- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다
- 두가지 방법
  - 깊이우선탐색(DFS)
  - 너비우선탐색(BFS)
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야하므로 후입선출 구조의 스택 사용

```python
V, E = map(int, input().split())
G = [[] for _ in range(V+1)]

for _ in range(E):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
    
visit = [0] * (V+1)
S = []
v = 1
S.append(v)
visit[v] = 1
print(1, end=' ')

While S:
    for w in G[v]:
        if visit[w]:
            continue
        S.append(v)
        visit[w] = 1
        v = w
        break
    else:
        S.pop()
    
```



